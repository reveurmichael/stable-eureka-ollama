def compute_reward(self, pos, action, state):
    speed_x = 0.3 * state[2] * (VIEWPORT_W / SCALE) / FPS
    distance_to_end = pos[0] / TERRAIN_LENGTH

    # Reward for moving forward and reaching the end
    reward_base = -10 + 20 * speed_x + 50 * distance_to_end

    # Penalty for falling down or getting stuck
    if state[11] == 1.0 or state[19] == 1.0:
        reward_base -= 100

    # Smoothness and stability bonus
    reward_base += np.exp(action[0]**2 + action[1]**2)

    return reward_base, {"moving_reward": 20 * speed_x, "distance_to_end": 50 * distance_to_end, "falling_penalty": -100 if state[11] == 1.0 or state[19] == 1.0 else 0, "smoothness_bonus": np.exp(action[0]**2 + action[1]**2)}