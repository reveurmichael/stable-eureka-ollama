def compute_reward(self, pos, action, state):
    x_distance = abs(pos[0] - TERRAIN_LENGTH)
    y_distance = abs(pos[1] - (VIEWPORT_H / SCALE) / 2)

    if x_distance < TERRAIN_GRASS * TERRAIN_STEP and not self.game_over:
        reward = np.exp((x_distance / (TERRAIN_GRASS * TERRAIN_STEP)) * TEMPERATURE) + np.exp(-y_distance * SMOOTHNESS)
        individual_reward = {'end_of_terrain': 1.0, 'height': -y_distance}
    elif pos[0] < 0:
        reward = -np.exp((pos[0] / (TERRAIN_LENGTH / 2)) * TEMPERATURE) - np.exp(-y_distance * SMOOTHNESS)
        individual_reward = {'falling': -1.0, 'height': -y_distance}
    else:
        reward = np.exp(x_distance / (TERRAIN_LENGTH / 2)) + np.exp(-y_distance * SMOOTHNESS)
        individual_reward = {'progress': x_distance, 'height': -y_distance}

    return reward, individual_reward