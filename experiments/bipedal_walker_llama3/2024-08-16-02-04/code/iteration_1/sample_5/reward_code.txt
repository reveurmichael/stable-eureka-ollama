def compute_reward(self, pos, action, state):
    distance = abs(pos[0] - TERRAIN_LENGTH)
    velocity = math.sqrt(state[2]**2 + state[3]**2)
    
    # Reward for moving forward and reaching the end
    reward_component1 = np.exp(-distance / 10.0) * (velocity ** 2.0)
    
    # Penalty for falling or getting stuck
    if pos[0] < 0:
        reward_component2 = -np.exp(5.0)
    else:
        reward_component2 = 0.0
    
    # Penalty for not moving
    if velocity < 0.1:
        reward_component3 = -np.exp(3.0)
    else:
        reward_component3 = 0.0
    
    total_reward = reward_component1 + reward_component2 + reward_component3
    return total_reward, {'forward_progress': reward_component1, 'falling_penalty': reward_component2, 'stagnation_penalty': reward_component3}