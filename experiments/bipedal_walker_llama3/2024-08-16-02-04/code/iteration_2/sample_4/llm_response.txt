```python
def compute_reward(self, pos, action, state):
    reward = -0.1
    individual_reward = {}

    if self.game_over:
        reward -= 100.0 * np.exp(2)
        individual_reward['game_over'] = -100.0 * np.exp(2)

    if pos[0] < (TERRAIN_LENGTH - TERRAIN_GRASS) * TERRAIN_STEP:
        reward += 10.0
        individual_reward['reached_goal'] = 10.0

    if not self.game_over and pos[0] > 0.5 * TERRAIN_LENGTH * TERRAIN_STEP:
        reward -= 1.0
        individual_reward['midpoint_reached'] = -1.0

    if action[0]**2 + action[1]**2 > 0.5:
        reward -= 1.0
        individual_reward['high_speed'] = -1.0

    return reward, individual_reward
```

The goal is to make the biped navigate a 2D environment and reach the end of the terrain while avoiding falling down or getting stuck. The reward function aims to promote reaching the end, moving forward, and maintaining speed while penalizing game over, high speed, and not reaching the midpoint.