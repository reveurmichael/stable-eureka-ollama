def compute_reward(self, pos, action, state):
    reached_end = int(pos[0] > (TERRAIN_LENGTH - TERRAIN_GRASS) * TERRAIN_STEP)
    distance_to_end = abs(TERRAIN_LENGTH - pos[0]) / TERRAIN_STEP
    reward_components = {}
    
    # Reward for reaching the end
    reward_components['reached_end'] = 10.0 * reached_end
    
    # Penalty for not moving forward
    if action.sum() < 1:
        reward_components['stagnation_penalty'] = -5.0
    else:
        reward_components['stagnation_penalty'] = 0.0
    
    # Reward for moving forward
    reward_components['distance_reward'] = distance_to_end * 10.0
    
    # Penalty for falling down (not being at the ground)
    if not all([leg.ground_contact for leg in self.legs]):
        reward_components['fall_penalty'] = -5.0
    else:
        reward_components['fall_penalty'] = 0.0
    
    total_reward = sum(r * np.exp(-temperature) for r, temperature in [('reached_end', 0.1), ('stagnation_penalty', 0.2), ('distance_reward', 0.3), ('fall_penalty', 0.4)])
    
    return total_reward, reward_components