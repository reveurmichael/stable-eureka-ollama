def compute_reward(self, pos, action, state):
    # Encourage the agent to reach the goal while minimizing falls and struggles
    distance_to_goal = TERRAIN_LENGTH - pos[0]
    
    if self.game_over or pos[0] < 0:
        return -100.0, {"terminal": True}
    elif pos[0] > (TERRAIN_LENGTH - TERRAIN_GRASS) * TERRAIN_STEP:
        return 100.0, {"success": True}
    
    # Introduce a scaling factor to balance distance and fitness
    reward_scale = 1.5
    
    # Adjust the fall penalty to make it less severe
    fall_penalty = -5.0 if state[-1] else 0.0
    
    # Calculate the struggle penalty based on agent's speed
    struggle_penalty = -2.0 if state[3] > 1.5 else 0.0
    
    reward = (distance_to_goal / TERRAIN_LENGTH) * reward_scale + fall_penalty + struggle_penalty
    individual_reward = {"distance_reward": (reward_scale * distance_to_goal) / TERRAIN_LENGTH,
                          "fall": fall_penalty, "struggle": struggle_penalty}
    
    return reward, individual_reward