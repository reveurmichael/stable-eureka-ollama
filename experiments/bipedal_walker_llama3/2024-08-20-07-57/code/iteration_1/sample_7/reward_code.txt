def compute_reward(self, pos, action, state):
    distance_to_goal = abs(pos[0] - TERRAIN_LENGTH)  # Reward closer to the goal
    penalty_for_falling = 10 if pos[1] < 0 else 0  # Punish for falling down

    # Scale and normalize the rewards
    distance_reward = np.exp(-distance_to_goal / TERRAIN_LENGTH)
    falling_penalty = -penalty_for_falling * 0.01  # scale penalty to be more significant

    # Combine rewards with a weighted sum
    reward = distance_reward + falling_penalty
    individual_reward = {'distance': distance_reward, 'falling': falling_penalty}

    return reward, individual_reward