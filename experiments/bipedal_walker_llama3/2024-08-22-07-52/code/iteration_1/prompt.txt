You are a reward engineer writing effective reward functions for reinforcement learning tasks. Your goal is to create a reward function to help the agent learn the task described in text. Use relevant environment variables as inputs. Example signature:
```python
def compute_reward(self, ...):
    ...
    return reward, {}
```
Do not use type hints. Return type: float, Dict[str, float].
Coding instructions: The reward function output should include:
1. Total reward (float)
2. Dictionary of individual reward components
Format as a Python code string: "```python ... ```". Tips:
1. Normalize rewards using transformations like np.exp. Introduce temperature parameters for each transformation.
2. Ensure input types match expected types.
3. Use only self. attributes from the environment class definition and input variables.
4. If you create a self var inside the compute_reward function you must consider that it is not previously defined in the environment class:
    e.g. if hasattr(self, 'var') is False: self.var = 0 else self.var += 1
5. No new input variables.
6. The python code must begin with: "```python ... ```"
7. Pass self as the first argument.
8. Do not compute fitness_score components.
9. Only create the reward function, do not create more functions.
10. Try to make everything smooth (when possible).
Provide the function code only, followed by a brief explanation (max 50 words).
Task description: The goal is to make a biped navigate a 2D environment:
- The biped starts standing at the left end of the terrain with the hull horizontal, and both legs in the same position with a slight knee angle
- The biped has to reach the right end of the terrain and avoid falling down, getting stuck while surpassing obstacles (e.g. gaps, steps, stairs)
- We do not want the biped to get stuck in a certain position, he should keep moving forward, as far as possible
- The biped should go as fast as possible, so it gets to the end in less steps. The fewer episode steps, the better if getting to the end
- It is more important to reach the end than being super smooth, because the agent could decide not to move to avoid falling down, which is not the goal
Environment code:
def step(self, action: np.ndarray):
    assert self.hull is not None

    # self.hull.ApplyForceToCenter((0, 20), True) -- Uncomment this to receive a bit of stability help
    control_speed = False  # Should be easier as well
    if control_speed:
        self.joints[0].motorSpeed = float(SPEED_HIP * np.clip(action[0], -1, 1))
        self.joints[1].motorSpeed = float(SPEED_KNEE * np.clip(action[1], -1, 1))
        self.joints[2].motorSpeed = float(SPEED_HIP * np.clip(action[2], -1, 1))
        self.joints[3].motorSpeed = float(SPEED_KNEE * np.clip(action[3], -1, 1))
    else:
        self.joints[0].motorSpeed = float(SPEED_HIP * np.sign(action[0]))
        self.joints[0].maxMotorTorque = float(
            MOTORS_TORQUE * np.clip(np.abs(action[0]), 0, 1)
        )
        self.joints[1].motorSpeed = float(SPEED_KNEE * np.sign(action[1]))
        self.joints[1].maxMotorTorque = float(
            MOTORS_TORQUE * np.clip(np.abs(action[1]), 0, 1)
        )
        self.joints[2].motorSpeed = float(SPEED_HIP * np.sign(action[2]))
        self.joints[2].maxMotorTorque = float(
            MOTORS_TORQUE * np.clip(np.abs(action[2]), 0, 1)
        )
        self.joints[3].motorSpeed = float(SPEED_KNEE * np.sign(action[3]))
        self.joints[3].maxMotorTorque = float(
            MOTORS_TORQUE * np.clip(np.abs(action[3]), 0, 1)
        )

    self.world.Step(1.0 / FPS, 6 * 30, 2 * 30)

    pos = self.hull.position
    vel = self.hull.linearVelocity

    for i in range(10):
        self.lidar[i].fraction = 1.0
        self.lidar[i].p1 = pos
        self.lidar[i].p2 = (
            pos[0] + math.sin(1.5 * i / 10.0) * LIDAR_RANGE,
            pos[1] - math.cos(1.5 * i / 10.0) * LIDAR_RANGE,
        )
        self.world.RayCast(self.lidar[i], self.lidar[i].p1, self.lidar[i].p2)

    state = [
        self.hull.angle,  # Normal angles up to 0.5 here, but sure more is possible.
        2.0 * self.hull.angularVelocity / FPS,
        0.3 * vel.x * (VIEWPORT_W / SCALE) / FPS,  # Normalized to get -1..1 range
        0.3 * vel.y * (VIEWPORT_H / SCALE) / FPS,
        self.joints[0].angle,
        # This will give 1.1 on high up, but it's still OK (and there should be spikes on hiting the ground, that's normal too)
        self.joints[0].speed / SPEED_HIP,
        self.joints[1].angle + 1.0,
        self.joints[1].speed / SPEED_KNEE,
        1.0 if self.legs[1].ground_contact else 0.0,
        self.joints[2].angle,
        self.joints[2].speed / SPEED_HIP,
        self.joints[3].angle + 1.0,
        self.joints[3].speed / SPEED_KNEE,
        1.0 if self.legs[3].ground_contact else 0.0,
    ]
    state += [l.fraction for l in self.lidar]
    assert len(state) == 24

    self.scroll = pos.x - VIEWPORT_W / SCALE / 5

    terminated = False
    if self.game_over or pos[0] < 0:
        terminated = True
    # stable-eureka: this is the function you must implement!
    reward, individual_reward = self.compute_reward(pos, action, state)

    fitness_score = self.compute_fitness_score(pos, action, state)

    if pos[0] > (TERRAIN_LENGTH - TERRAIN_GRASS) * TERRAIN_STEP:
        terminated = True

    if self.render_mode == "human":
        self.render()

    info = individual_reward.update({'fitness_score': fitness_score})

    return np.array(state, dtype=np.float32), reward, terminated, False, info

Reward reflection:
We trained a RL policy using the provided reward function code and tracked (on evaluation on several points of the training stage) the values of individual reward components, along with global policy metrics such as fitness scores and episode lengths. Maximum, mean, and minimum are provided:
   distance_reward: [21.456541195180584, 18.198799901191613, 20.152606857136078, 18.526644969194805, 18.732874163751006, 19.04721417477067, 19.64790359599849, 19.6087595264966, 20.39142900759453, 18.84871957291739]. Max: 21.456541195180584 - Mean: 19.461149296423176 - Min: 18.198799901191613 
   angle_penalty: [-235.73048525638006, -81.47442599336891, -41.0793695111618, -32.910089823749075, -34.19518141514541, -54.70350827522318, -77.14311005485857, -53.23430833024688, -88.63606355787229, -42.89644394725903]. Max: -32.910089823749075 - Mean: -74.20029861652652 - Min: -235.73048525638006 
   angular_velocity_penalty: [-3.933792840346641, -2.7388766561055915, -2.1097837913206132, -1.7205899715028181, -1.1817328052005824, -1.1032845330725918, -1.378023374219961, -1.6021268772970982, -1.8488651542895658, -1.5400462151344496]. Max: -1.1032845330725918 - Mean: -1.9157122218489913 - Min: -3.933792840346641 
   action_penalty: [-1530.3970600930031, -1489.3166989020924, -1471.896634111114, -1403.7931049206948, -1183.8511991566907, -1027.8238860636648, -967.1922533418166, -915.6931389146403, -1060.0733146765476, -960.5345604067292]. Max: -915.6931389146403 - Mean: -1201.0571850586994 - Min: -1530.3970600930031 
   obstacle_penalty: [1280.5365202390321, 1262.0377241722267, 1241.1362557706639, 1254.723123797126, 1256.6792136745871, 1260.101690204281, 1256.9240401239883, 1259.8621978402916, 1264.660218465668, 1253.8978542085654]. Max: 1280.5365202390321 - Mean: 1259.0558838496431 - Min: 1241.1362557706639 
   fitness_score: [-68.39426697046412, -60.412462070670955, -57.47806848391147, -49.59693040033442, -34.792401875343174, -28.274634799442993, -26.07057810974121, -24.223881282273666, -29.637988172318934, -25.51667691072081]. Max: -24.223881282273666 - Mean: -40.439788907522185 - Min: -68.39426697046412 
   reward: [155.06620700188796, 185.8538796612993, 190.72489099181257, 217.99619787849952, 284.9599117198959, 329.6998626533896, 342.3858227925375, 364.0248425407335, 316.78744497243315, 348.90398440975696]. Max: 364.0248425407335 - Mean: 273.6403044622246 - Min: 155.06620700188796 
   episode_length: [1600.0, 1600.0, 1600.0, 1600.0, 1600.0, 1600.0, 1600.0, 1600.0, 1600.0, 1600.0]. Max: 1600.0 - Mean: 1600.0 - Min: 1600.0 

Please analyze the policy feedback and provide an improved reward function to better solve the task. Tips for analyzing feedback:
1. If a reward component's values are nearly identical, or it increases when it should decrease (minimize) and vice versa, consider the following options:
    a. Change its scale or temperature parameter.
    b. Re-write the component.
    c. Discard the component.
2. If a component's magnitude is significantly larger, re-scale it.
3. You want to maximize the fitness score as it is the ground truth evaluator.
4. You want to maximize positive reward components values during training and minimize negative reward components values.
5. If the fitness score is not improving during training, try to change the reward function.
Analyze each existing reward component first, then write the new reward function code proposal.Stable-Eureka best iteration  (you should modify it!): 
    # Generated code by stable-eureka
    def compute_reward(self, pos, action, state):
        # Distance-based reward: incentivizing movement to the right
        distance_reward = pos.x
        distance_reward = np.exp(distance_reward / 400.0) - 1
    
        # Stability reward: penalizing large angle and angular velocity
        angle_penalty = -np.abs(state[0])
        angle_penalty = np.tanh(angle_penalty / 0.5)  # More stringent scaling
    
        angular_velocity_penalty = -np.abs(state[1])
        angular_velocity_penalty = np.tanh(angular_velocity_penalty / 0.5)  # Increased impact with stringent scaling
    
        # Smoothness reward: penalizing high-speed actions
        action_penalty = -np.sum(np.abs(action)) / len(action)
        action_penalty = np.tanh(action_penalty / 0.2)  # Reduced impact for less stringent scaling
    
        # Proximity to Lidar points: encouraging avoidance of obstacles
        obstacle_penalty = -np.min([l.fraction for l in self.lidar])
        obstacle_penalty = np.exp(obstacle_penalty)  # Exponential scaling for higher penalty with increased weight
    
        # Total reward: a weighted sum with adjusted weights
        reward = (distance_reward
                  + 0.2 * angle_penalty
                  + 0.1 * angular_velocity_penalty
                  + 0.3 * action_penalty
                  + 0.5 * obstacle_penalty)  # Higher weight given to distance reward and obstacle penalty
    
        individual_reward = {
            "distance_reward": distance_reward,
            "angle_penalty": angle_penalty,
            "angular_velocity_penalty": angular_velocity_penalty,
            "action_penalty": action_penalty,
            "obstacle_penalty": obstacle_penalty
        }
    
        return reward, individual_reward

Your reward code is: 