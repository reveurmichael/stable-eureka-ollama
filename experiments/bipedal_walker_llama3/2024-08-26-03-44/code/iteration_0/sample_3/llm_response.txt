```python
def compute_reward(self, pos, action, state):
    distance_reward = np.exp((TERRAIN_LENGTH - pos[0]) / 400.0) - 1
    angle_penalty = -np.abs(state[0])
    angular_velocity_penalty = -np.abs(state[1])

    # Penalty for not moving forward (modified)
    movement_penalty = -np.maximum(0, np.sum(np.sign(action))) * 10

    obstacle_penalty = -np.min([l.fraction for l in self.lidar]) ** 2
    total_reward = distance_reward + 0.05 * angle_penalty + 0.05 * angular_velocity_penalty - movement_penalty + 0.3 * obstacle_penalty

    individual_reward = {
        "distance_reward": distance_reward,
        "angle_penalty": angle_penalty,
        "angular_velocity_penalty": angular_velocity_penalty,
        "movement_penalty": movement_penalty,
        "obstacle_penalty": obstacle_penalty
    }

    return total_reward, individual_reward