def compute_reward(self, state, m_power, s_power, terminated):
    # Compute individual rewards for main and side engines
    main_engine_reward = -0.1 * np.abs(m_power)  # penalty for using main engine
    side_engine_reward = -0.05 * np.abs(s_power)  # penalty for using side engines

    if terminated:
        reward = -10.0  # strong penalty when the episode is terminated
    else:
        reward = main_engine_reward + side_engine_reward  # sum individual rewards

    return reward, individual_reward