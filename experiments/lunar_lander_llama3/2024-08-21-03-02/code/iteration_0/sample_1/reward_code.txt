def compute_reward(state, m_power, s_power, terminated):
    # Distance to Helipad
    distance_to_helipad = np.sqrt((state[0] + VIEWPORT_W / SCALE / 2) ** 2 + (state[1] - self.helipad_y - LEG_DOWN / SCALE) ** 2)
    reward_distance = -distance_to_helipad

    # Lander Stability
    stability_reward = -np.abs(state[4])  # penalize large angle deviations

    # Collision Avoidance
    if state[-1] + state[-2]:  # at least one leg is in contact with the ground
        collision_penalty = -0.5
    else:
        collision_penalty = 0

    # Reward for Landing
    if terminated and abs(state[0]) < 0.05:  # successful landing
        reward_landing = 10
    else:
        reward_landing = 0

    individual_reward = m_power * reward_distance + s_power * stability_reward + collision_penalty + reward_landing

    return individual_reward, {'distance_to_helipad': reward_distance, 'stability_reward': stability_reward, 'collision_penalty': collision_penalty, 'reward_landing': reward_landing}