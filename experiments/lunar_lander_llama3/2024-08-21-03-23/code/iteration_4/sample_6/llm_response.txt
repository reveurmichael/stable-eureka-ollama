Based on the provided code, it appears that the reward function is implemented in the `compute_reward` method. The method takes four arguments: `state`, `m_power`, `s_power`, and `terminated`.

The reward calculation seems to be based on the following:

1. If the game is over (`self.game_over`) or if the lander has gone outside the viewport (`abs(state[0]) >= 1.0`), then a termination signal is sent.
2. If the lander is not awake, then another termination signal is sent.

The reward function itself is likely implemented as follows:

```
def compute_reward(self, state, m_power, s_power, terminated):
    if terminated:
        return -10.0, {"termination": 1.0}  # game over or out of bounds
    elif self.lander.position[1] > (self.helipad_y + LEG_DOWN / SCALE):  # landed safely
        return 5.0, {"landing": 1.0}
    else:
        return -1.0, {}  # still in the air
```

This reward function gives a penalty of -10 when the game is over or the lander goes outside the viewport. If the lander lands safely, it gets a reward of +5. In all other cases (i.e., the lander is still in the air), it receives a penalty of -1.

Please note that this is an inference and not explicitly stated in the provided code. The actual reward function might be different.