def compute_reward(state, m_power, s_power, terminated):
    if terminated:
        # Penalty for not achieving the goal or going out of bounds
        return -1.0, {}

    # Reward for stable position and velocity while grounded
    pos_reward = 0.5 * (abs(state[0]) + abs(state[1]))
    vel_reward = 0.2 * (abs(state[2]) + abs(state[3]))

    # Action-specific rewards:
    if m_power > 0:  # Main engine power-on
        return 0.8, {'main_engine': 0.8}
    elif s_power > 0:  # Side engines on
        return 0.4, {'side_engines': 0.4}

    # Default reward (stable state)
    return 0.1, {}