def compute_reward(state, m_power, s_power, terminated):
    # Landing reward (1.0 if successful, 0.5 otherwise)
    landing_reward = 1.0 if not terminated and abs(state[0]) < 1.0 else 0.5

    # Orientation reward (1.0 if angle change is small, 0.0 otherwise)
    orientation_reward = 1.0 if abs(state[4] - initial_angle) < 0.1 else 0.0

    # Distance penalty (higher values for moving away from the starting point)
    distance_penalty = 1.0 - (state[0] ** 2 + state[1] ** 2) / (VIEWPORT_W ** 2 + VIEWPORT_H ** 2)

    reward = landing_reward + orientation_reward - distance_penalty
    individual_reward = {"landing": landing_reward, "orientation": orientation_reward, "distance": distance_penalty}

    return reward, individual_reward