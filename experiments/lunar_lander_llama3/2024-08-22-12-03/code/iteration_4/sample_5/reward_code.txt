def compute_reward(state, m_power, s_power, terminated):
    if terminated:
        # Game over or failed to land; punish the agent
        return -100, {}

    distance_from_helipad = abs(state[1])  # penalize for being far away
    velocity_reduction = state[3] / FPS  # reward for reducing velocity

    main_engine_thrust = m_power * (1 if s_power > 0.5 else 0)  # only count main engine thrust when side engines are active
    engine_usage_punishment = -0.2 * main_engine_thrust

    side_engine_orientation_reward = 0.3 * np.clip(abs(state[4]), 10, 30)

    reward = +10 if distance_from_helipad < 0.1 else -0.5 * distance_from_helipad
    reward += velocity_reduction
    reward += engine_usage_punishment
    reward += side_engine_orientation_reward

    return reward, {'main_engine_thrust': main_engine_thrust, 'side_engine_orientation': np.round(side_engine_orientation_reward, 2)}