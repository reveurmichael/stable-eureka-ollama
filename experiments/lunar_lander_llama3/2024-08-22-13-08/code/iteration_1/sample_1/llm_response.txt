Here's a possible reward function based on the given environment and goal:

```
def compute_reward(self, state, m_power, s_power, terminated):
    # Reward for moving away from the helipad
    pos_x = (state[0] + 1) * VIEWPORT_W / SCALE / 2
    reward = -pos_x ** 2

    # Penalty for crashing or going too far away from the helipad
    if terminated:
        reward -= 100.0

    return reward, {'crash': terminated}
```

This reward function gives a negative reward for moving away from the helipad (further away is worse), and a large penalty for crashing or going too far away from the helipad (much worse). This should encourage the agent to move towards the helipad while avoiding crashes.