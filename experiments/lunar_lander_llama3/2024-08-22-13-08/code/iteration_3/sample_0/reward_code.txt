def compute_reward(state, m_power, s_power, terminated):
    # Position-based reward
    pos_reward = -abs(state[0])  # negative distance from helipad

    # Orientation-based reward
    orient_reward = np.cos(state[4]) * 10.0  # cosine of orientation (normalized)

    # Engine usage penalty
    engine_penalty = -m_power * 0.1 - s_power * 0.05  # penalty for engine use

    individual_reward = pos_reward + orient_reward + engine_penalty

    if terminated:
        return -100, individual_reward  # high penalty when game is over
    else:
        return individual_reward, individual_reward